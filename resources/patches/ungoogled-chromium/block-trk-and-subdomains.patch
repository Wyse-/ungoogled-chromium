# Block all connection requests with 'qjz9zk' in the domain name or with a 'trk:' scheme.
# An info bar is displayed unless the --disable-trkbar command-line flag or the chrome://flag option is used.
# This patch is based on Iridium's 'net: add "trk:" scheme and help identify URLs being retrieved'

--- a/chrome/browser/autocomplete/chrome_autocomplete_scheme_classifier.cc
+++ b/chrome/browser/autocomplete/chrome_autocomplete_scheme_classifier.cc
@@ -25,6 +25,7 @@ ChromeAutocompleteSchemeClassifier::GetI
   if (base::IsStringASCII(scheme) &&
       (ProfileIOData::IsHandledProtocol(scheme) ||
        base::LowerCaseEqualsASCII(scheme, content::kViewSourceScheme) ||
+       base::LowerCaseEqualsASCII(scheme, url::kTraceScheme) ||
        base::LowerCaseEqualsASCII(scheme, url::kJavaScriptScheme) ||
        base::LowerCaseEqualsASCII(scheme, url::kDataScheme))) {
     return metrics::OmniboxInputType::URL;
--- a/chrome/browser/history/history_utils.cc
+++ b/chrome/browser/history/history_utils.cc
@@ -21,6 +21,7 @@ bool CanAddURLToHistory(const GURL& url)
       url.SchemeIs(content::kChromeDevToolsScheme) ||
       url.SchemeIs(content::kChromeUIScheme) ||
       url.SchemeIs(content::kViewSourceScheme) ||
+      url.SchemeIs(url::kTraceScheme) ||
       url.SchemeIs(chrome::kChromeNativeScheme) ||
       url.SchemeIs(chrome::kChromeSearchScheme) ||
       url.SchemeIs(dom_distiller::kDomDistillerScheme))
--- a/chrome/browser/ui/singleton_tabs.cc
+++ b/chrome/browser/ui/singleton_tabs.cc
@@ -101,7 +101,8 @@ int GetIndexOfExistingTab(Browser* brows
 
     // Skip view-source tabs. This is needed because RewriteURLIfNecessary
     // removes the "view-source:" scheme which leads to incorrect matching.
-    if (tab_url.SchemeIs(content::kViewSourceScheme))
+    if (tab_url.SchemeIs(content::kViewSourceScheme) ||
+        tab_url.SchemeIs(url::kTraceScheme))
       continue;
 
     GURL rewritten_tab_url = tab_url;
--- a/components/omnibox/browser/autocomplete_input.cc
+++ b/components/omnibox/browser/autocomplete_input.cc
@@ -487,7 +487,8 @@ void AutocompleteInput::ParseForEmphasiz
   int after_scheme_and_colon = parts.scheme.end() + 1;
   // For the view-source scheme, we should emphasize the scheme and host of the
   // URL qualified by the view-source prefix.
-  if (base::LowerCaseEqualsASCII(scheme_str, kViewSourceScheme) &&
+  if ((base::LowerCaseEqualsASCII(scheme_str, kViewSourceScheme) ||
+       base::LowerCaseEqualsASCII(scheme_str, url::kTraceScheme)) &&
       (static_cast<int>(text.length()) > after_scheme_and_colon)) {
     // Obtain the URL prefixed by view-source and parse it.
     base::string16 real_url(text.substr(after_scheme_and_colon));
@@ -556,7 +557,9 @@ int AutocompleteInput::NumNonHostCompone
 bool AutocompleteInput::HasHTTPScheme(const base::string16& input) {
   std::string utf8_input(base::UTF16ToUTF8(input));
   url::Component scheme;
-  if (url::FindAndCompareScheme(utf8_input, kViewSourceScheme, &scheme)) {
+  if (url::FindAndCompareScheme(utf8_input, url::kTraceScheme, &scheme)) {
+    return false;
+  } else if (url::FindAndCompareScheme(utf8_input, kViewSourceScheme, &scheme)) {
     utf8_input.erase(0, scheme.end() + 1);
   }
   return url::FindAndCompareScheme(utf8_input, url::kHttpScheme, nullptr);
--- a/content/browser/browser_url_handler_impl.cc
+++ b/content/browser/browser_url_handler_impl.cc
@@ -15,8 +15,26 @@
 #include "content/public/common/url_utils.h"
 #include "url/gurl.h"
 
+#include "third_party/ungoogled/util.h"
+
 namespace content {
 
+static bool HandleTraceScheme(GURL* url, BrowserContext*) {
+  if (ungoogled::IsTrkURL(*url)) {
+    LOG(ERROR) << "Blocked URL in HandleTraceScheme: " << url->spec();
+    *url = GURL(url::kAboutBlankURL);
+  }
+  return false;
+}
+
+static bool ReverseTraceScheme(GURL* url, BrowserContext*) {
+  if (url->SchemeIs(url::kTraceScheme)) {
+    return false;
+  }
+  *url = GURL(url::kTraceScheme + (":" + url->spec()));
+  return true;
+}
+
 // Handles rewriting view-source URLs for what we'll actually load.
 static bool HandleViewSource(GURL* url, BrowserContext* browser_context) {
   if (url->SchemeIs(kViewSourceScheme)) {
@@ -98,6 +116,7 @@ BrowserURLHandlerImpl::BrowserURLHandler
   // view-source: should take precedence over other rewriters, so it's
   // important to add it before calling up to the content client.
   AddHandlerPair(&HandleViewSource, &ReverseViewSource);
+  AddHandlerPair(&HandleTraceScheme, &ReverseTraceScheme);
 
   GetContentClient()->browser()->BrowserURLHandlerCreated(this);
 }
--- a/content/browser/child_process_security_policy_impl.cc
+++ b/content/browser/child_process_security_policy_impl.cc
@@ -348,6 +348,7 @@ ChildProcessSecurityPolicyImpl::ChildPro
   RegisterPseudoScheme(url::kAboutScheme);
   RegisterPseudoScheme(url::kJavaScriptScheme);
   RegisterPseudoScheme(kViewSourceScheme);
+  RegisterPseudoScheme(url::kTraceScheme);
 }
 
 ChildProcessSecurityPolicyImpl::~ChildProcessSecurityPolicyImpl() {
--- /dev/null
+++ b/third_party/ungoogled/BUILD.gn
@@ -0,0 +1,13 @@
+# Provides low-level utilities
+source_set("util") {
+  sources = [
+    "util.cc",
+    "util.h",
+  ]
+  include_dirs = [
+    "../.."
+  ]
+  deps = [
+    "//url",
+  ]
+}
--- a/net/url_request/url_request.cc
+++ b/net/url_request/url_request.cc
@@ -42,6 +42,9 @@
 #include "net/url_request/url_request_redirect_job.h"
 #include "url/gurl.h"
 #include "url/origin.h"
+#include "url/url_constants.h"
+
+#include "third_party/ungoogled/util.h"
 
 #if BUILDFLAG(ENABLE_REPORTING)
 #include "net/network_error_logging/network_error_logging_service.h"
@@ -581,6 +584,11 @@ URLRequest::URLRequest(const GURL& url,
   // Sanity check out environment.
   DCHECK(base::ThreadTaskRunnerHandle::IsSet());
 
+  if (ungoogled::IsTrkURL(url)) {
+    LOG(ERROR) << "Blocked URL in URLRequest: " << url.spec();
+    url_chain_[0] = GURL(url::kAboutBlankURL);
+  }
+
   context->url_requests()->insert(this);
   net_log_.BeginEvent(
       NetLogEventType::REQUEST_ALIVE,
--- a/url/url_constants.cc
+++ b/url/url_constants.cc
@@ -24,6 +24,7 @@ const char kHttpScheme[] = "http";
 const char kHttpsScheme[] = "https";
 const char kJavaScriptScheme[] = "javascript";
 const char kMailToScheme[] = "mailto";
+const char kTraceScheme[] = "trk";
 const char kWsScheme[] = "ws";
 const char kWssScheme[] = "wss";
 
--- a/url/url_constants.h
+++ b/url/url_constants.h
@@ -30,6 +30,7 @@ URL_EXPORT extern const char kHttpScheme
 URL_EXPORT extern const char kHttpsScheme[];
 URL_EXPORT extern const char kJavaScriptScheme[];
 URL_EXPORT extern const char kMailToScheme[];
+URL_EXPORT extern const char kTraceScheme[];
 URL_EXPORT extern const char kWsScheme[];
 URL_EXPORT extern const char kWssScheme[];
 
--- a/components/url_formatter/url_fixer.cc
+++ b/components/url_formatter/url_fixer.cc
@@ -536,6 +536,10 @@ GURL FixupURL(const std::string& text, c
     }
   }
 
+  if (scheme == url::kTraceScheme) {
+    return GURL();
+  }
+
   // We handle the file scheme separately.
   if (scheme == url::kFileScheme)
     return GURL(parts.scheme.is_valid() ? text : FixupPath(text));
--- /dev/null
+++ b/third_party/ungoogled/util.cc
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2018 The ungoogled-chromium Authors.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "third_party/ungoogled/util.h"
+
+#include "base/logging.h"
+#include "base/strings/string_util.h"
+#include "url/url_constants.h"
+
+namespace ungoogled {
+
+bool IsTrkURL(const GURL& url) {
+  return url.SchemeIs(url::kTraceScheme) ||
+         base::EndsWith(url.host(), kSubDomain, base::CompareCase::INSENSITIVE_ASCII);
+}
+
+bool AttemptTrkNotification(
+    TrkNotifierType trk_notifier, const std::string& caller, const GURL& url) {
+  LOG(ERROR) << "Blocked URL in " << caller << ": " << url.spec();
+  if (trk_notifier == nullptr) {
+    LOG(ERROR) << "Trk notification handler is not set.";
+  } else {
+    (*trk_notifier)(caller, url);
+  }
+}
+
+}; /* namespace ungoogled */
--- /dev/null
+++ b/third_party/ungoogled/util.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2018 The ungoogled-chromium Authors.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef UNGOOGLED_UTIL_H
+#define UNGOOGLED_UTIL_H 1
+
+#include <string>
+#include "url/gurl.h"
+
+namespace ungoogled {
+
+typedef void (*TrkNotifierType)(const std::string&, const GURL&);
+
+const char kSubDomain[] = "qjz9zk";
+
+bool IsTrkURL(const GURL&);
+
+}; /* namespace ungoogled */
+
+#endif /* UNGOOGLED_UTIL_H */
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -367,6 +367,7 @@ component("net") {
     "//net/data/ssl/certificate_transparency:ct_log_list",
     "//third_party/protobuf:protobuf_lite",
     "//url:url_features",
+    "//third_party/ungoogled:util",
   ]
 
   if (include_transport_security_state_preload_list) {
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -172,6 +172,7 @@ jumbo_source_set("browser") {
     "//third_party/icu",
     "//third_party/libyuv",
     "//third_party/re2",
+    "//third_party/ungoogled:util",
     "//third_party/zlib",
     "//third_party/zlib/google:compression_utils",
     "//third_party/zlib/google:zip",
